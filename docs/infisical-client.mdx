# Infisical Client Integration Summary

## Overview

The `LoadEnv` class provides a universal, production-ready wrapper around Infisical's Python SDK, designed to simplify secret management across different environments and use cases. This wrapper abstracts the complexity of direct SDK usage while maintaining full feature parity.

## Architecture

### Core Components

1. **LoadEnv Class**: Main wrapper class providing high-level API
2. **Caching Layer**: TTL-based cache using `cachetools` for performance optimization
3. **Logging Integration**: Comprehensive logging via `loguru` for observability
4. **Type Safety**: Full type hints and Pydantic models for better developer experience

### Design Principles

- **Thin Wrapper**: Minimal abstraction layer, direct SDK method mapping
- **Universal Access**: Works across all environments (dev, staging, prod)
- **Developer Experience**: Simple API with sensible defaults
- **Production Ready**: Built-in error handling, logging, and caching

## Integration with Infisical SDK

### SDK Method Mapping

The `LoadEnv` class maps to Infisical SDK methods as follows:

| LoadEnv Method | Infisical SDK Method | Notes |
|----------------|---------------------|-------|
| `get()` | `secrets.get_secret_by_name()` | With caching layer |
| `get_all()` | `secrets.list_secrets()` | Returns dict of SecretStr |
| `list_secrets()` | `secrets.list_secrets()` | Returns list of BaseSecret |
| `create_secret()` | `secrets.create_secret_by_name()` | With cache invalidation |
| `update_secret()` | `secrets.update_secret_by_name()` | With cache invalidation |
| `secret_by_name()` | `secrets.get_secret_by_name()` | Returns full BaseSecret object |

### Authentication

The wrapper supports Infisical's machine identity authentication:

- **Machine Identity Client ID**: Identifies the machine/service
- **Machine Identity Client Secret**: Authenticates the machine
- **Host Configuration**: Supports custom Infisical instances

Authentication can be provided via:
- Constructor parameters
- Environment variables (`INFISICAL_MACHINE_ID`, `INFISICAL_SECRET_KEY`)
- Per-call overrides (for multi-tenant scenarios)

## Key Features

### 1. Intelligent Caching

- **TTL Cache**: 1-hour default TTL reduces API calls
- **Automatic Invalidation**: Cache cleared on create/update operations
- **Key Strategy**: Composite keys based on project, environment, path, and secret name

### 2. Comprehensive Logging

All operations are logged with appropriate levels:

```python
# Example log output
INFO: Initializing LoadEnv client
SUCCESS: Infisical SDK client initialized successfully
INFO: Fetching secret 'DATABASE_URL' from Infisical (project: abc123, env: dev)
DEBUG: Cache hit for secret: API_KEY
ERROR: Failed to retrieve secret 'MISSING_KEY': Secret not found
```

### 3. Environment Management

Support for multiple environments with type-safe literals:

```python
Environment = Literal["dev", "staging", "prod"]
```

This ensures compile-time checking and prevents invalid environment values.

### 4. Path-Based Organization

Secrets can be organized in paths, supporting hierarchical secret management:

```
/app/database
/app/api
/infrastructure/aws
```

## Usage Patterns

### Pattern 1: Application Initialization

```python
# app.py
from secrets_env import LoadEnv
import asyncio

async def init_app():
    secrets = LoadEnv()
    
    # Load all required secrets at startup
    db_url = await secrets.get("DATABASE_URL", project="app-project")
    api_key = await secrets.get("API_KEY", project="app-project")
    
    return {
        "database_url": db_url.get_secret_value(),
        "api_key": api_key.get_secret_value()
    }
```

### Pattern 2: Lazy Loading

```python
# Lazy secret loading with caching
class Service:
    def __init__(self):
        self._secrets = LoadEnv()
        self._cache = {}
    
    async def get_config(self, key: str):
        if key not in self._cache:
            secret = await self._secrets.get(key, project="project-id")
            self._cache[key] = secret.get_secret_value()
        return self._cache[key]
```

### Pattern 3: Multi-Environment Deployment

```python
# Deploy to different environments
async def deploy(env: str):
    client = LoadEnv()
    
    # Environment-specific secrets
    config = await client.get_all(
        project="deployment-project",
        env=env  # "dev", "staging", or "prod"
    )
    
    # Use secrets for deployment
    for key, value in config.items():
        set_environment_variable(key, value.get_secret_value())
```

## Best Practices

### 1. Client Reuse

**Do:**
```python
# Create once, reuse everywhere
client = LoadEnv()

async def handler1():
    return await client.get("SECRET_1", project="p1")

async def handler2():
    return await client.get("SECRET_2", project="p2")
```

**Don't:**
```python
# Don't create new clients for each operation
async def handler():
    client = LoadEnv()  # Inefficient
    return await client.get("SECRET", project="p1")
```

### 2. Error Handling

**Do:**
```python
try:
    secret = await client.get("CRITICAL_SECRET", project="p1")
    value = secret.get_secret_value()
except ValueError as e:
    # Handle configuration errors
    logger.error(f"Config error: {e}")
    raise
except Exception as e:
    # Handle SDK errors
    logger.error(f"Secret retrieval failed: {e}")
    # Fallback or retry logic
```

### 3. Secret Value Access

**Do:**
```python
secret = await client.get("API_KEY", project="p1")
# Use SecretStr for type safety
api_key: str = secret.get_secret_value()
```

**Don't:**
```python
# Don't access internal attributes directly
secret = await client.get("API_KEY", project="p1")
api_key = secret._secret  # Wrong - use get_secret_value()
```

### 4. Cache Awareness

Be aware that cached values may be up to 1 hour old. For critical secrets that change frequently:

```python
# Force fresh fetch by using credential override
# (creates new SDK instance, bypasses cache)
secret = await client.get(
    "DYNAMIC_SECRET",
    project="p1",
    client_id=client._default_client_id,  # Forces new SDK instance
    client_secret=client._default_client_secret
)
```

## Security Considerations

1. **Secret Storage**: Never commit secrets to version control
2. **Environment Variables**: Use environment variables for credentials in production
3. **SecretStr Usage**: Always use Pydantic's `SecretStr` to prevent accidental logging
4. **Access Control**: Ensure proper machine identity permissions in Infisical
5. **Audit Logging**: All operations are logged for audit trails

## Performance Characteristics

- **Cache Hit**: ~0.001ms (in-memory lookup)
- **Cache Miss**: ~50-200ms (API call to Infisical)
- **Batch Operations**: `get_all()` is more efficient than multiple `get()` calls
- **Concurrent Access**: Thread-safe caching via `cachetools`

## Troubleshooting

### Common Issues

1. **"Project ID must be provided"**
   - Set `INFISICAL_PROJECT_ID` environment variable
   - Or pass `project` parameter to methods

2. **"Failed to initialize Infisical SDK client"**
   - Verify `INFISICAL_MACHINE_ID` and `INFISICAL_SECRET_KEY` are set
   - Check network connectivity to Infisical host

3. **"Secret not found"**
   - Verify secret exists in Infisical
   - Check project ID, environment, and path are correct
   - Ensure machine identity has read permissions

4. **Stale cached values**
   - Wait for TTL expiration (1 hour default)
   - Or invalidate cache by creating/updating the secret

## Migration from Direct SDK Usage

If you're currently using Infisical SDK directly:

**Before:**
```python
from infisical_sdk import InfisicalSDKClient

client = InfisicalSDKClient(
    client_id="id",
    client_secret="secret"
)

secret = await client.secrets.get_secret_by_name(
    secret_name="KEY",
    project_id="project",
    environment_slug="dev"
)
value = secret.secret_value
```

**After:**
```python
from secrets_env import LoadEnv

client = LoadEnv(
    machine_identity_client_id="id",
    machine_identity_client_secret="secret"
)

secret = await client.get(
    key="KEY",
    project="project",
    env="dev"
)
value = secret.get_secret_value()
```

## References

- [Infisical Python SDK Documentation](https://infisical.com/docs/sdks/python)
- [Infisical Machine Identity](https://infisical.com/docs/documentation/platform/machine-identity)
- [Pydantic SecretStr](https://docs.pydantic.dev/latest/concepts/secrets/)
- [Loguru Documentation](https://loguru.readthedocs.io/)

## Summary

The `LoadEnv` wrapper provides a clean, production-ready interface to Infisical's secret management system. With built-in caching, logging, and error handling, it simplifies secret management while maintaining the flexibility and power of the underlying SDK. The wrapper is designed to be universally applicable across different projects, environments, and use cases.

